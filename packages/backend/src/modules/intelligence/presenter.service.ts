import { Injectable } from '@nestjs/common';
import { FieldDefinition, ServiceBlueprint } from '../blueprint/interfaces/blueprint.interface';
import { LlmMessage } from '../../core/llm/llm.types';
import { PromptExecutionService } from './prompt-execution.service';
import { PROMPT_KEYS } from '../../core/prompt/prompt.constants';

@Injectable()
export class PresenterService {
  constructor(
    private readonly promptExecutionService: PromptExecutionService,
  ) {}

  /**
   * Generate a question to ask the user for a specific field for the first time.
   * @param field The field definition containing the question template and context
   * @param languageConfig Optional language configuration for strict enforcement
   * @param history Optional conversation history to include
   * @returns A natural language question generated by the AI
   */
  async generateQuestion(
    field: FieldDefinition,
    languageConfig?: { mode: 'adaptive' | 'strict'; defaultLanguage: string },
    history: LlmMessage[] = [],
  ): Promise<string> {
    if (languageConfig?.mode === 'strict') {
      const augmentation = `CRITICAL: You must ONLY communicate in ${languageConfig.defaultLanguage}. If the user speaks another language in response, you cannot process it.`;
      return await this.promptExecutionService.executeChatWithAugmentedSystem(
        PROMPT_KEYS.PRESENTER_QUESTION_SYSTEM,
        augmentation,
        PROMPT_KEYS.PRESENTER_QUESTION_USER,
        {
          questionTemplate: field.questionTemplate,
          aiContext: field.aiContext,
        },
        history,
      );
    }
    
    return await this.promptExecutionService.executeChat(
      PROMPT_KEYS.PRESENTER_QUESTION_SYSTEM,
      PROMPT_KEYS.PRESENTER_QUESTION_USER,
      {
        questionTemplate: field.questionTemplate,
        aiContext: field.aiContext,
      },
      history,
    );
  }

  /**
   * Generate an error response when user input fails local validation.
   * Explains the error gently and re-asks the question.
   * @param field The field definition that failed validation
   * @param invalidInput The user's invalid input
   * @param errorReason The reason why the input was invalid
   * @param languageConfig Optional language configuration for strict enforcement
   * @param history Optional conversation history to include
   * @returns A natural language error message and re-prompt
   */
  async generateErrorResponse(
    field: FieldDefinition,
    invalidInput: string,
    errorReason: string = 'The provided value is missing or does not match the expected format.',
    languageConfig?: { mode: 'adaptive' | 'strict'; defaultLanguage: string },
    history: LlmMessage[] = [],
  ): Promise<string> {
    if (languageConfig?.mode === 'strict') {
      const augmentation = `CRITICAL: You must ONLY communicate in ${languageConfig.defaultLanguage}.`;
      return await this.promptExecutionService.executeChatWithAugmentedSystem(
        PROMPT_KEYS.PRESENTER_ERROR_SYSTEM,
        augmentation,
        PROMPT_KEYS.PRESENTER_ERROR_USER,
        {
          questionTemplate: field.questionTemplate,
          invalidInput: invalidInput,
          errorReason: errorReason,
        },
        history,
      );
    }
    
    return await this.promptExecutionService.executeChat(
      PROMPT_KEYS.PRESENTER_ERROR_SYSTEM,
      PROMPT_KEYS.PRESENTER_ERROR_USER,
      {
        questionTemplate: field.questionTemplate,
        invalidInput: invalidInput,
        errorReason: errorReason,
      },
      history,
    );
  }

  /**
   * Generate a contextual response when the user asks a question instead of answering.
   * Answers their question using the blueprint context, then steers back to the form.
   * @param field The current field definition
   * @param userQuestion The user's question about the form
   * @param languageConfig Optional language configuration for strict enforcement
   * @param history Optional conversation history to include
   * @returns A contextual answer followed by a re-prompt
   */
  async generateContextualResponse(
    field: FieldDefinition,
    userQuestion: string,
    languageConfig?: { mode: 'adaptive' | 'strict'; defaultLanguage: string },
    history: LlmMessage[] = [],
  ): Promise<string> {
    if (languageConfig?.mode === 'strict') {
      const augmentation = `CRITICAL: You must ONLY communicate in ${languageConfig.defaultLanguage}.`;
      return await this.promptExecutionService.executeChatWithAugmentedSystem(
        PROMPT_KEYS.PRESENTER_CONTEXTUAL_SYSTEM,
        augmentation,
        PROMPT_KEYS.PRESENTER_CONTEXTUAL_USER,
        {
          questionTemplate: field.questionTemplate,
          aiContext: field.aiContext,
          userQuestion: userQuestion,
        },
        history,
      );
    }
    
    return await this.promptExecutionService.executeChat(
      PROMPT_KEYS.PRESENTER_CONTEXTUAL_SYSTEM,
      PROMPT_KEYS.PRESENTER_CONTEXTUAL_USER,
      {
        questionTemplate: field.questionTemplate,
        aiContext: field.aiContext,
        userQuestion: userQuestion,
      },
      history,
    );
  }

  /**
   * Get the welcome message for new conversations.
   * @returns The welcome message string
   */
  getWelcomeMessage(): string {
    return 'Hello! What service would you like to use today?';
  }

  /**
   * Format a list of available services for display.
   * @param services Array of service blueprints
   * @returns Formatted service list with prompt
   */
  formatServiceList(services: ServiceBlueprint[]): string {
    const serviceList = services
      .map((s) => `â€¢ ${s.name} (${s.id})`)
      .join('\n');
    
    return `Here are the available services:\n\n${serviceList}\n\nWhich service would you like to use?`;
  }

  /**
   * Get the error message when service selection is unclear.
   * @returns The unclear selection error message
   */
  getServiceSelectionUnclearResponse(): string {
    return 'I\'m not sure which service you\'re looking for. Could you please clarify? You can also ask "What services are available?" to see all options.';
  }

  /**
   * Get the completion message when all data has been collected.
   * @returns The completion message string
   */
  getCompletionMessage(): string {
    return 'Thank you! I have collected all the necessary information. Your request has been completed.';
  }

  /**
   * Get the fallback message when next step cannot be determined.
   * @returns The fallback message string
   */
  getFallbackMessage(): string {
    return 'I\'m not sure what to ask next.';
  }

  /**
   * Generate a language requirement announcement for strict language mode.
   * @param languageCode The ISO language code (e.g., 'nl-NL', 'de-DE')
   * @param history Optional conversation history to include
   * @returns A message announcing the language requirement in the target language
   */
  async getLanguageRequirementAnnouncement(languageCode: string, history: LlmMessage[] = []): Promise<string> {
    return await this.promptExecutionService.executeChat(
      PROMPT_KEYS.PRESENTER_LANGUAGE_ANNOUNCEMENT_SYSTEM,
      PROMPT_KEYS.PRESENTER_LANGUAGE_ANNOUNCEMENT_USER,
      {
        languageCode: languageCode,
      },
      history,
    );
  }
}
